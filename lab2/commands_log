3) Сохранить в виде ascii- файла F1.var значение внутренних переменных shell и номера
процессов в системе.
    Код shell скрипта, выполняющего данные действия приведён нижен и содержиться в файле
part3.sh в директории lab2.

    #!/bin/sh
    echo $HOME >> F1.var
    echo $PATH >> F1.var
    echo $TERM >> F1.var
    echo $MAIL >> F1.var
    ps ax | awk '{print $1}' >> F1.var

    Результат работы данного скрипта содержиться в файле F1.var

4) Переопределить значения переменных PS1, PS2, сохранить в ascii- файле F2.var значения
внутренних переменных.
    Код shell скрипта, выполняющего данные действия приведён нижен и содержиться в файле
part4.sh в директории lab2.

    #!/bin/sh
    PS1="It's PS1 variable"
    PS2="It's PS2 variable"
    echo $PS1 >> F2.var
    echo $PS2 >> F2.var

    Результат работы данного скрипта содержиться в файле F2.var

    Поскольку измнения переменных PS1 и PS2 производились в скриптах с помощью перекрытия переменных, не их перезаписи,то
    при переходи к терминалу командной строки никаких проблем с данны переменными, плане их содержания, не будет.Однако, если перезаписать
    эти переменные в командном терминале, то далее, проводить корректную работу с терминалом будет невозможно в виду того, что переменные PS1 и
    PS2 содержать необходимые сведения для работы командного интерпретатора.

5) Вернуться к исходному значению внутренних переменныхshell.
    Для возврата к исходным значениям в скрипте part4.sh были созданы промежуточные переменные для хранения старых значений PS1 и PS2
    при небоходимости возрата к исходным значениям PS1 и PS2 локальные переменные перезаписываются.

6)В каталоге lab4 получить копию файла
    /ete/skel/local.profile
с именем .profile, определить в нем значения переменных DIGIT_FOR_LAB,
MYOWNNAME, TIMEZONE, MYGROUP, DAY_OF_WEEK_TODAY, а также измените на
действующие значения внутренних переменных интерпретатора PATH и HOME.
Стартуйте модифицированную таким образом командную оболочку. Убедитесь в
результате.

    В виду отсутствия файла local.profile был скопирован файл .bashrc, содержащий
    переменные для текущего пользователя, которыые загружаются при создании сеанса работы с
    терминалом

    Копирование:
    cp /etc/skel/.bashrc ./.profile

    Для добавление переменных в рабочую область был выбран файл ~/.bashrc , содержащий настройки для работы с терминалом
    В данном терминале были объявлены следующие переменные

    export DIGIT_FOR_LAB="DIGIT_FOR_LAB =2"
    export MYOWNNAME="My name is Artem"
    export TIMEZONE="Timezone is +3 UTC"
    export MYGROUP="MY GROUP is A-04M-25"
    export DAY_OF_WEEK_TODAY="MONDAY"

    Ниже привведены результаты возовов данных переменных в терминале

    patt@patt-BMH-WDX9:~$ echo $DIGIT_FOR_LAB
    DIGIT_FOR_LAB =2

    patt@patt-BMH-WDX9:~$ echo $MYOWNNAME
    My name is Artem

    patt@patt-BMH-WDX9:~$ echo $TIMEZONE
    Timezone is +3 UTC

    patt@patt-BMH-WDX9:~$ echo $MYGROUP
    MY GROUP is A-04M-25

    patt@patt-BMH-WDX9:~$ echo $DAY_OF_WEEK_TODAY
    MONDAY

    Также были переопределены переменные PATH и  HOME следующим образом:

    export HOME="This is a HOME variable"
    export PATH="This is a PATH variable"

    Ниже привведены результаты возовов данных переменных в терминале

    patt@patt-BMH-WDX9:/home/patt$ echo $PATH
    This is a PATH variable

    patt@patt-BMH-WDX9:/home/patt$ echo $HOME
    This is a HOME variable


7) Напишите программу на языке shell - "скрипт", которая по вводимой вами произвольной
последовательности десятичных чисел осуществляла бы вычисление промежуточных сумм и
выводила конечный результат на экран и в файл sh.result. Используйте в программе значение
переменной интерпретатора S#. Если номер Вашей бригады четный - постарайтесь обойтись
оператором for, если нечетный - конструкцией if.

    Вариант бригады - 1.

    Ниже,приведён код shell скрипта, выполняющего данное задание.Код данной программы содержиться в скрипте part7.sh

    #!/bin/sh

    a=0
    b=0

    while [ $# -gt 1 ]
    do
        if [ $# -gt 0 ]
        then
            a=$1
            shift
            b=$1
            echo $(( a + b )) | tee -a sh.result
        fi
    done


8) Напишите скрипт, который выводил бы через каждые десять секунд на экран некоторое
сообщение только в том случае, если наступит определенное время в определенный день.
Режим запуска - фоновый. Уточнение задания - см. табл.4.1

    Ниже приведён код скрипта на shell, выполняющий данные действия
    #!/bin/sh

    MOUNTH=09
    HOUR_OF_DAY=12
    MINUTE_OF_DAY=32

    #То есть вывод сообщения должен происходить 8 сентября в 13:35

    $(rm -rf comms.res)


    while true
    do
        CURRENT_MOUNTH=$(date --date="today" +%m)
        CURRENT_DAY_OF_WEEK_TODAY=$(date --date="today" +%u)
        CURRENT_HOUR_OF_DAY=$(date --date="today" +%H)
        CURRENT_MINUTE_OF_DAY=$(date --date="today" +%M)
        CURRENT_TIMEZONE=$(date --date="today" +%Z)

        if [ $CURRENT_MOUNTH -eq  $MOUNTH ] && [ $CURRENT_DAY_OF_WEEK_TODAY -eq  $DAY_OF_WEEK_TODAY ] && [ $CURRENT_HOUR_OF_DAY -eq  $HOUR_OF_DAY ] && [ $CURRENT_MINUTE_OF_DAY -eq $MINUTE_OF_DAY ] && [ $CURRENT_TIMEZONE = $TIMEZONE ]
        then
            echo "It's 14:00 September the eigth" | tee -a comms.res
            sleep 10
        fi
    done

    Сам скрипт находится в файле part8.sh

    Запуск в фоновом режиме происходит с помощью следующей команды:
    ./part8.sh & disown

9) Напишите скрипт, который проверял бы наличие процесса, связанного со скриптом по
пункту номер 8) и останавливал бы его, если количество сообщений, выведенных на экран
скриптом по пункту номер 8) превысит некоторое число. Уточнение задания - см. табл.4.2.


    Ниже приведён скрипт shell, выполняющий данные действия.

    #!/bin/sh

    SKRIPT_NAME="part8"
    PID=0

    if [ $(ps ax | grep -E ".*( sudo nohup )?$SKRIPT_NAME" | wc -l) -ge 2 ]
    then
        echo "process found"
        #PID=$(ps ax | grep -E ".*( sudo nohup )?$SKRIPT_NAME" | head -n 1 | awk '{print $1}')
        PID=$(ps ax | grep -E ".*[0-9]\s/bin/sh\s./$SKRIPT_NAME" | head -n 1 | awk '{print $1}')
        echo "$PID"
    else
        echo "process not found"
        exit
    fi


    while true
    do
        if [ $(( $(cat comms.res 2>/dev/null | wc -l) % $DIGIT_FOR_LAB )) -eq 0 ] && [ -f ./comms.res ]
        then
            echo "Обнаружено превышение, остановка вывода"
            $(kill $PID)
            exit
        fi
    done

    Сам скрипт находится в файле part9.sh

    Запуск в фоновом режиме происходит с помощью следующей команды:
    ./part9.sh & disown


        Примечание:скрипты 8 и 9 следует запускать последовательно


10) Напишите скрипт без использования диалога с оператором на языке shell, который через
несколько минут (5-10) закроет все процессы, связанные с пунктами 7 - 9. Если номер Вашей
бригады четный - постарайтесь обойтись конструкцией if, иначе - конструкцией for.
Примечание: перед запуском скрипта покажите его текст преподавателю и только после
получения разрешения - запустите на исполнение. Подсказка к выполнению: кое-о-чем Вы
позаботились в начале лабораторного задания; это "кое-что" позволит Вам выполнить
задание.

    Номер бригады нечётный - используем конструкцию for
    Ниже приведён код скрипта,выполняющий данные дейсвтия.Сам код содержится
    в файле скрипта part10.sh

    #!/bin/sh
    SKRIPT_NAME="part"
    TIME_INIT=$(shuf -i 5-10 -n 1)
    START_TIME=$(date --date='today' +%M)
    END_TIME=$(date --date='today' +%M)


    $(rm -rf PID.s)

    $(ps ax | grep -E ".*[0-9]\s/bin/sh\s./part" | head -n 3 | awk '{print $1}' >> PID.s)


    while [ $(( END_TIME - START_TIME )) -ne $TIME_INIT ]
    do
        END_TIME=$(date --date='today' +%M)
        sleep 1

    done


    while read line
    do

        $(kill $line)

    done < PID.s

    $(rm -rf PID.s)




11) После запуска скрипта п.10 вернитесь в оболочку shell которая была в Вашем
распоряжении до выполнения п.6).

        Для возврата терминла к состоянию до пункта 6 требуется удалить переменные, записанные в файл ~/.bashrc, а также
        выполнить команду source ~/.bashrc


12) Завершите сеанс работы с ОС через минуту запуска некоторого скрипта.

    Код скрипта,выполняющий данный пункт приведён ниже и содержится в файле part12.sh


    #!/bin/sh
    START_TIME=$(date --date='today' +%M)
    END_TIME=$(date --date='today' +%M)

    while true
    do
        END_TIME=$(date --date='today' +%M)
        if [ $(( $END_TIME - $START_TIME )) -eq 1 ]
        then
            $(shutdown -P now)
        fi
    done
